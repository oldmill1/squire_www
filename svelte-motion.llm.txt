# Svelte-Motion Complete Guide - Learnings from WolverineButton

## Core Concepts

### 1. Basic Motion Component Structure
```svelte
<Motion 
    let:motion
    whileHover={{ scale: 1.05 }}
    whileTap={{ scale: 0.95 }}
    animate={{ x: 100, y: 50 }}
    transition={{ duration: 0.25, ease: [0, 0, 0, 2.5] }}
>
    <div use:motion>Animated Content</div>
</Motion>
```

### 2. Essential Imports
```typescript
import { Motion, M } from 'svelte-motion';
```

## Motion Component Props

### Animation Triggers
- **whileHover**: Animations when mouse hovers over element
- **whileTap**: Animations when element is clicked/tapped
- **animate**: Base animation state or conditional animations

### Animation Properties
- **Transform**: `x`, `y`, `scale`, `rotate`
- **Visual**: `opacity`
- **Layout**: `width`, `height`

### Transitions
```typescript
transition={{ 
    duration: 0.25,           // Animation duration in seconds
    ease: [0, 0, 0, 2.5]      // Custom easing array (cubic-bezier)
}}
```

## Advanced Patterns

### 1. Conditional Animations
```svelte
<Motion 
    let:motion
    animate={isHovered ? {
        y: -24,
        rotate: 4,
        opacity: 1
    } : {
        y: 0,
        opacity: 0
    }}
>
    <div use:motion>Content</div>
</Motion>
```

### 2. Nested Motions
Multiple Motion components can be nested for complex animations:
```svelte
<Motion let:motion whileHover={{ scale: 1.05 }}>
    <div use:motion>
        <Motion let:motion animate={{ y: -10 }}>
            <div use:motion>Nested content</div>
        </Motion>
    </div>
</Motion>
```

## SVG Animation

### Critical: SVG Type Compatibility Issue
**Problem**: TypeScript error with SVG elements:
```
Argument of type 'SVGSVGElement' is not assignable to parameter of type 'HTMLElement'
```

**Solution**: Use wrapper function for SVG compatibility:
```typescript
// In script section
function applyMotion(node: any, motionAction: any) {
    return motionAction(node);
}
```

```svelte
<!-- For SVG elements, use wrapper function -->
<Motion let:motion isSVG={true}>
    <svg use:applyMotion={motion}>
        <!-- SVG content -->
    </svg>
</Motion>
```

### SVG Animation Properties
SVG elements support all transform properties:
- `x`, `y` for translation
- `rotate` for rotation
- `scale` for scaling

## Real-World Example: WolverineButton Patterns

### 1. Main Container Animation
```svelte
<Motion 
    let:motion
    whileHover={{ scale: 1.05 }}
    whileTap={{ scale: 0.95 }}
    transition={{ duration: 0.25, ease: [0, 0, 0, 2.5] }}
>
    <div use:motion role="button" tabindex="0">
        <!-- Button content -->
    </div>
</Motion>
```

### 2. Drawer Animations (Slide & Fade)
```svelte
<Motion 
    let:motion
    animate={isHovered ? {
        y: -24,
        rotate: 4,
        opacity: 1
    } : {
        y: 0,
        opacity: 0
    }}
    whileTap={{ 
        y: 0,
        scale: 0.5,
        opacity: 1
    }}
    transition={{ duration: 0.125, ease: [0, 0, 0, 2.5] }}
>
    <div use:motion>Drawer content</div>
</Motion>
```

### 3. Corner SVG Animations
```svelte
<Motion 
    let:motion
    isSVG={true}
    animate={isHovered ? {
        x: -36,
        y: -36,
        rotate: 180
    } : {
        x: -24,
        y: -24,
        rotate: 180
    }}
    whileTap={{ 
        x: -12,
        y: -12,
        rotate: 180
    }}
    transition={{ duration: 0.25, ease: [0, 0, 0, 2.5] }}
>
    <svg use:applyMotion={motion}>
        <!-- SVG path -->
    </svg>
</Motion>
```

## Real-World Example: Switch Component Patterns

### 1. Toggle Switch with State-Driven Animations
```svelte
<script lang="ts">
    import { Motion } from 'svelte-motion';
    
    let checked: boolean = false;
    let isHovered: boolean = false;
</script>

<!-- Container with hover/tap effects -->
<Motion 
    let:motion
    whileHover={{ scale: 1.05 }}
    whileTap={{ scale: 0.95 }}
    transition={{ duration: 0.2, ease: [0.4, 0, 0.2, 1] }}
>
    <label class="switch" use:motion>
        <input type="checkbox" {checked} onchange={handleChange}>
        
        <!-- Background with dynamic box-shadow -->
        <Motion 
            let:motion
            animate={checked ? {
                boxShadow: "rgba(0, 0, 0, 0.62) 0px 0px 5px inset, #22cc3f 0px 0px 0px 2px inset, #22cc3f 0px 0px 0px 24px inset, rgba(224, 224, 224, 0.45) 0px 1px 0px 0px"
            } : {
                boxShadow: "rgba(0, 0, 0, 0.62) 0px 0px 5px inset, rgba(0, 0, 0, 0.21) 0px 0px 0px 24px inset, #22cc3f 0px 0px 0px 0px inset, rgba(224, 224, 224, 0.45) 0px 1px 0px 0px"
            }}
            transition={{ duration: 0.3, ease: [0.4, 0, 0.2, 1] }}
        >
            <span class="slider" use:motion>
                <!-- Thumb with position and color animation -->
                <Motion 
                    let:motion
                    animate={checked ? {
                        x: 22,
                        backgroundColor: "white"
                    } : {
                        x: 0,
                        backgroundColor: "#e3e3e3"
                    }}
                    whileHover={{
                        backgroundColor: checked ? "white" : "#f0f0f0"
                    }}
                    transition={{ duration: 0.3, ease: [0.4, 0, 0.2, 1] }}
                >
                    <span class="slider-thumb" use:motion></span>
                </Motion>
            </span>
        </Motion>
    </label>
</Motion>
```

### 2. Key Learnings from Switch Implementation

#### Converting CSS Transitions to Motion
- **CSS `transform: translateX()` → Motion `x` property**: Use `x` for horizontal movement instead of CSS transforms
- **CSS `transition` → Motion `transition`**: Replace CSS transitions with Motion's transition object
- **CSS `box-shadow` → Motion `boxShadow`**: Animate complex box-shadow strings directly in Motion
- **CSS pseudo-classes → Motion `whileHover`**: Replace `:hover` with Motion's `whileHover` prop

#### State-Driven Animation Pattern
```typescript
// Use boolean state to drive animations
let checked: boolean = false;

// Animate based on state in Motion component
animate={checked ? {
    x: 22,           // Move thumb right when checked
    backgroundColor: "white"  // Change thumb color
} : {
    x: 0,            // Reset thumb position
    backgroundColor: "#e3e3e3"  // Default thumb color
}}
```

#### Nested Motion for Complex Components
- **Outer Motion**: Container hover/tap effects
- **Middle Motion**: Background state changes (box-shadow)
- **Inner Motion**: Thumb movement and color changes
- Each layer can have independent transitions and properties

#### Timing and Easing Consistency
```typescript
// Match original CSS timing: cubic-bezier(0.4, 0, 0.2, 1)
transition={{ 
    duration: 0.3, 
    ease: [0.4, 0, 0.2, 1] 
}}
```

#### Svelte 5 Event Handler Syntax
```svelte
<!-- Use modern syntax, not on:change -->
<input type="checkbox" {checked} onchange={handleChange}>
```

## Best Practices

### 1. Performance
- Use shorter durations for micro-interactions (0.125s)
- Use longer durations for major transitions (0.25s)
- Consistent easing across related animations

### 2. Accessibility
- Maintain `role="button"` and `tabindex="0"` for interactive elements
- Preserve keyboard event handlers
- Don't remove semantic HTML structure

### 3. State Management
- Use reactive variables for complex animation states:
```typescript
let isHovered = false;
let isActive = false;
```

### 4. Animation Coordination
- Parent animations affect child elements
- Use different transition durations for visual hierarchy
- Coordinate hover states across multiple elements

## Common Issues & Solutions

### 1. SVG Type Errors
**Issue**: TypeScript complains about SVG elements
**Solution**: Use wrapper function approach shown above

### 2. Animation Not Working
**Check**: 
- `let:motion` is declared
- `use:motion` is applied to target element
- Motion component props are correctly formatted

### 3. Performance Issues
**Optimize**:
- Reduce number of animated properties
- Use GPU-accelerated transforms (x, y, scale, rotate)
- Avoid animating layout properties frequently

## Animation Property Reference

### Transform Properties
- `x`, `y`: Translation (px or %)
- `scale`: Scale factor (1 = normal)
- `rotate`: Rotation in degrees

### Visual Properties
- `opacity`: 0 (transparent) to 1 (opaque)

### Transition Properties
- `duration`: Seconds (number)
- `ease`: Array [x1, y1, x2, y2] for cubic-bezier
- `delay`: Seconds before animation starts

## Integration with Svelte 5

### Modern Svelte Patterns
- Works with Svelte 5 syntax
- Compatible with `{@render}` blocks
- Integrates with Svelte stores and reactive statements

### Component Structure
```typescript
// Script section
import { Motion } from 'svelte-motion';
import styles from './Component.module.scss';

let isHovered = false;

// Optional: SVG compatibility wrapper
function applyMotion(node: any, motionAction: any) {
    return motionAction(node);
}
```

This guide covers all practical patterns learned from implementing the WolverineButton and Switch components with svelte-motion, including state-driven animations, CSS-to-Motion conversion techniques, and complex nested motion patterns.

## Latest Learnings: WolverineButton Deep Dive (Nov 2025)

### Critical Issue: Initial Load Animation Problem

**Problem**: Corner arcs were animating from origin to their default positions on page load, creating a jarring visual effect.

**Root Cause**: Motion components with `animate` props automatically animate from initial state (0,0) to the specified values.

**Solution**: Use `initial={false}` prop to prevent initial animation:
```svelte
<Motion 
    let:motion
    initial={false}  // Prevents initial load animation
    animate={isHovered ? {
        x: -80,
        y: -40,
        rotate: 180
    } : {
        x: -70,  // Start position (no animation)
        y: -30,
        rotate: 180
    }}
>
    <svg use:applyMotion={motion}>
        <!-- SVG content appears immediately at position -->
    </svg>
</Motion>
```

### Positioning Strategy: Rectangle vs Square

**Challenge**: Default positioning created square-like corner arrangement, but button needed rectangular frame.

**Solution**: Asymmetric x/y values for rectangular proportions:
```svelte
// Default state: Wider rectangle
animate={isHovered ? {
    x: -80,  // Wider horizontal
    y: -40,  // Shorter vertical
} : {
    x: -70,  // Default wider
    y: -30,  // Default shorter
}}

// This creates: 140px × 60px rectangle instead of 96px × 96px square
```

### Animation State Coordination

**Three-State Pattern**: Default → Hover → Active
```svelte
animate={isHovered ? {
    x: -80,   // Hover: furthest out
    y: -40
} : {
    x: -70,   // Default: medium distance
    y: -30
}}
whileTap={{ 
    x: -40,   // Active: closest in
    y: -20
}}
```

### CSS vs Motion Hybrid Approach

**Learning**: Sometimes pure CSS is better for certain effects:
- **Motion**: Best for complex coordinate animations, state-driven movements
- **CSS**: Better for simple hover effects, filters, color changes

**Hybrid Pattern**:
```svelte
<!-- Motion for complex positioning -->
<Motion let:motion initial={false} animate={{ x: -70, y: -30 }}>
    <svg use:applyMotion={motion}>
        <!-- SVG positioned by Motion -->
    </svg>
</Motion>

<!-- CSS for simple visual effects -->
<style>
.btn-container:hover {
    --corner-color: #475569;  /* Color change via CSS */
    .btn-corner {
        filter: none;          /* Filter effect via CSS */
    }
}
</style>
```

### Debugging Invisible Elements

**Problem**: Corner arcs not displaying despite correct code.

**Debugging Steps**:
1. **Check z-index**: Ensure elements aren't behind others
2. **Check overflow**: Add `overflow: visible` to container
3. **Check stroke properties**: Ensure `stroke-width` is set
4. **Check positioning**: Verify coordinates aren't positioning off-screen

**Solution Pattern**:
```scss
.btn-corner {
  z-index: 1;           // Bring to front
  stroke-width: 1;      // Make visible
}

.btn-container {
  overflow: visible;    // Don't clip corners
  margin: 40px;         // Ensure space
}
```

### Performance Optimization

**Learning**: Motion vs CSS performance trade-offs:
- **Motion**: Better for complex, coordinated animations
- **CSS**: Better for simple, frequent micro-interactions
- **Hybrid**: Use Motion for positioning, CSS for visual effects

**Optimized Pattern**:
```svelte
<!-- Motion handles expensive coordinate calculations -->
<Motion let:motion initial={false} animate={{ x: -70, y: -30 }}>
    <svg use:applyMotion={motion} class="btn-corner">
        <!-- SVG -->
    </svg>
</Motion>

<!-- CSS handles cheap visual changes -->
<style>
.btn-corner {
    transition: filter 0.25s ease;  /* CSS for simple effects */
}
</style>
```

### Key Takeaways

1. **Always use `initial={false}`** when you want elements to appear at their final position immediately
2. **Asymmetric positioning** creates better visual proportions for rectangular layouts
3. **Hybrid CSS/Motion approach** often performs better than Motion-only
4. **Debug systematically**: z-index → overflow → stroke properties → positioning
5. **Coordinate systems**: Motion uses relative positioning from element center, CSS uses absolute positioning from container edges

### Final Recommended Pattern

```svelte
<script>
import { Motion } from 'svelte-motion';

function applyMotion(node: any, motionAction: any) {
    return motionAction(node);
}

let isHovered = false;
</script>

<!-- Optimized corner animation -->
<Motion 
    let:motion
    isSVG={true}
    initial={false}
    animate={isHovered ? {
        x: -80, y: -40, rotate: 180  // Hover state
    } : {
        x: -70, y: -30, rotate: 180  // Default (no animation)
    }}
    whileTap={{ 
        x: -40, y: -20, rotate: 180  // Active state
    }}
    transition={{ duration: 0.25, ease: [0, 0, 0, 2.5] }}
>
    <svg use:applyMotion={motion}>
        <!-- SVG content -->
    </svg>
</Motion>
```

This pattern provides:
- ✅ No initial load animation
- ✅ Rectangular proportions
- ✅ Smooth state transitions
- ✅ Optimal performance
- ✅ Maintainable code structure
